# -*- coding: utf-8 -*-
"""FEM_HW2_FN11-71_Urdenko.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lRQkOkvZDuDO5KPqm8crKmUeQu1AOWGq
"""

# Commented out IPython magic to ensure Python compatibility.
#@title Введите кол-во КЭ в области
# %reset -f
# Количество КЭ в Омега, задается пользователем
N = 810 #@param {type:"integer"}
try:
    # Импорт необходимых библиотек
    import math, time
    import numpy as np
except Exception as ex:
    print("Произошла ошибка при запуске:")
    print(ex)
    print("Возможно, отсутствует библиотека Numpy")
    input()       

# Время начала работы программы
total_start = time.time()

# Переменная, отвечающая за вывод информации о КЭ в консоль:
FE_INFO_PRINT = False # если False - информация не выводится
if FE_INFO_PRINT:
    # настройка опций печати информации о КЭ.
    # В данном случае числа выводятся с одним знаком после запятой
    np.set_printoptions(precision=1,suppress=True, linewidth=120)

# Размеры бруса:
a = 200   # по оси x
b = 40   # по оси y
c = 40   # по оси z

print("Пользовательское кол-во КЭ:", N)

# Обработка пользовательского N - не всякое число подходит,
# т.к. используются тетраэдры, делящие куб на 6 равных по объему частей.
# Операция a // b = [a/b] - целая часть от деления, где a,b - целые числа
N = N // 6   # столько кубов будет в области Омега

# В качестве стороны, на которой определяется
# количество разбиений на кубы, выбрана сторона c.
# Т.е., если сторона c разбита на 2 части, то 
# строна b разбита на (2 * b/c) частей, сторона a - на (2 * a/c)
# Всего кубов в области 2 * (2 * b/c) * (2 * a/c).
# Важно, чтобы результат a/c и b/c являлся целым числом 
# (иначе это разбиение не будет являться разбиением на кубы).
# Следующая формула учитывает равенство b = c:
# всего кубов в области (n ^ 3) * (a / c) = N  => 
n = int(math.pow(N // ( a//c ), 1/3)) # Кол-во кубов на стороне бруса c

if n <= 0:
    # При размерах данного варианта минимум кубов = 5 => миниум 30 тетраэдров
    n = 1
    print('Кол-во КЭ равно минимальному:', a//c * 6)

print("Кол-во КЭ приведено к ближайшему снизу возможному:", n * n * n * a//c * 6)
print("Общее количество кубов:", n * n * n * a//c)
print('Количество кубов на стороне с (или b):', n)

h = c / n # шаг сетки, длинна стороны куба.

# Далее node_id (номер узла) - уникальный номер узла в глобальной нумерации.
# Словарь (хэш-таблица) вида { номер_узла : (x,y,z) }:
Nodes_id2coord = {}
# Словарь (хэш-таблица) вида { (x,y,z) : номер_узла }:
Nodes_coord2id = {}

FEs = list() # Список для хранения конечных элементов
# set() - множество для хранения уникальных элементов,
# сложность операций вставки, проверки вхождения элемента в множество ~ O(1)
Sigma_u_1 = set() # Множество для хранений node_id узлов, которые лежат на границе Сигма_1
Sigma_u_2 = set() # Множество для хранений node_id узлов, которые лежат на границе Сигма_2

# Данные задачи:
ro = 10210  # плотность молибдена
E = 212  # модуль Юнга
nu = 0.29  # коэффициент Пуассона
l1 = E * nu / ( (1 + nu) * (1 - 2*nu) )  # параметр Ламе
l2 = E / (2 + 2 * nu)  # параметр Ламе
# Для работы с матрицами небольшого размера используется
# мат. пакет Numpy. Т.к. Python в чистом виде не оптимизирован 
# для научных вычислений, многократное использование собственных функций для
# работы с матрицами было бы не эффективным. Numpy же в своей реализации
# использует язык C для вычислений, что делает его идеальным 
# инструментов для множественных матричных операций.
C = np.array([
    [l1+2*l2,  l1,       l1,          0, 0, 0],
    [l1,       l1+2*l2,  l1,          0, 0, 0],
    [l1,       l1,       l1+2*l2,     0, 0, 0],
    [0, 0, 0,                        l2, 0, 0],
    [0, 0, 0,                        0, l2, 0],
    [0, 0, 0,                        0, 0, l2],
])  # матрица тензора модулей упругости

mu = 10 ** (-3)  # скалярная функция mu на границе Сигма_сигма
p = 10 ** (-3)  # давление, скалярная функция на границе Сигма_сигма
norm_on_Sigma_sigma_0 = np.array([0, 0, -1]) # вектор внешней нормали к Сигма_сигма при z = 0
norm_on_Sigma_sigma_c = np.array([0, 0, 1]) # вектор внешней нормали к Сигма_сигма при z = с

t_e_Sigma_sigma_0 = -p * norm_on_Sigma_sigma_0  # вектор t_e на границе Сигма_сигма при z = 0
t_e_Sigma_sigma_c = -p * norm_on_Sigma_sigma_c  # вектор t_e на границе Сигма_сигма при z = c

# Список функций для определения, находится ли узел node_id на границе Сигма_сигма
def if_on_Sigma_sigma_0(node_id):
    # Координата узла z == 0 ?
    # Nodes_id2coord[node_id] возращает кортеж координат узла (x,y,z)
    # (x,y,z)[2] = z
    return Nodes_id2coord[node_id][2] == 0

def if_on_Sigma_sigma_c(node_id):
    # Координата узла z == c ?
    return Nodes_id2coord[node_id][2] == c

# Класс разреженных матриц формата CSR
class CSR_Matrix:
    def __init__(self, G, dim):
        """
        Функция создания разреженной матрицы формата CSR
        Параметры
        ---------
        G - словарь вида ('номер_строки, номер_столбца') : 'значение', 
        в котором записаны ненулевые элементы матрицы.
            G = {
                (i_1, j_1) : val_1,
                (i_2, j_3) : val_2,
                (i_3, j_3) : val_3,
                ...
            }
        Элементы, котрых нет в G - нулевые - не сохраняются.
        dim - размерность квадратной матрицы
        """
        self.dim = dim # размерность
        self.indptr = []
        self.data = []
        self.indices = []

        self.indptr.append(0)
        i_old = 0
        k = 0

        for i,j in sorted(G):
            """
            Проходим по словарю, отсортированному по ключам вида ('номер_строки, номер_столбца').
            Пример: Порядок прохода по G = { 
                (1,1): 1, 
                (2,5): 2,
                (1,2): 3,
                (3,1): 4,
                (1,5): 5
            }
            Тогда порядок для sorted(G) = {
                (1,1): 1,
                (1,2): 3,
                (1,5): 5,
                (2,5): 2,
                (3,1): 4
            }
            Опервация sorted() высоко оптимизирована.
            """
            if i != i_old:
                i_old = i
                self.indptr.append(k+self.indptr[-1])
                k = 0 
            self.data.append( G[(i,j)] )
            self.indices.append(j)
            k += 1
        self.indptr.append(k+self.indptr[-1])

    def dot(self, vector):
        """
        Функция умножения матрицы на вектор справа
        Параметры
        ---------
        vector - входной вектор (одномерный массив любого типа)
        """
        assert self.dim == len(vector) # Проверяем соответствие размерностей
        result = np.zeros(self.dim) # Инициализируем результирующий вектор нулями
        for i in range(self.dim):
            for j in range(self.indptr[i], self.indptr[i + 1]):
                # j изменяется от self.indptr[i] до self.indptr[i + 1] с шагом 1
                result[i] += vector[self.indices[j]] * self.data[j]
        return result

# Класс для реализации метода сопряженных градиентов
class СonjugateGradientSolver:
    """
    Класс "Решатель", реализующий интерфейс решения 
    СЛАУ методом сопряженных градиентов
    """

    def __init__(self, eps = 0.001, max_iter = 1000):
        """
        Функция создания решателя
        Параметры
        ---------
        eps - точность для оценки невязки
        max_iter - максимальное количество итераций метода
        """
        self.eps = eps
        self.max_iter = max_iter
        
    def __call__(self, G, F):
        """
        Функция поиска решения СЛАУ
        Параметры
        ---------
        G - квадратная матрица СЛАУ
        F - вектор СЛАУ
        (размерность вектора и матрицы должны совпадать!)
        """

        print('Старт метода сопряженных градиентов')
        # Проверка размерностей:
        assert len(F) == G.dim
        dim = G.dim

        # Если a,b - векторы,
        # то a.dot(b) - операция скалярнго произведения a * b.
        # Если G - матрица, f -  вектор, 
        # то G.dot(f) - операция умножения вектора f на матрицу G справа

        iter_count = 0 # номер текущей итерации
        x = 0.5 * np.ones(dim) # начальное приближение - вектор [0.5, 0.5, ..., 0.5]
        r0 = F - G.dot(x) # начальная невязка (вектор)
        p = r0 # вектор

        # Оцениваем норму вектора как модуль максимального элемента.
        # Можно использовать и другие нормы.
        if max( abs(r0) ) < self.eps:
            # начальное приближение удовлетворяет указанной точности
            print('Окончательная невязка:', max( abs(r0) ) )
            return x
        
        for iter_count in range(self.max_iter):
            iter_count += 1

            # Вывод промежуточных результатов работы:
            if iter_count % 100 == 0:
                print(iter_count, "-я итерация, невязка:", max( abs(r0) ))
            
            # Промежуточные результаты вычислений:
            # Т.к. в чистом виде Python не опимизирован
            # для научных вычислений, оптимальнее не вызывать
            # нашу функцию умножения вектора на матрицу несколько раз.
            tmp1 = G.dot(p)
            tmp2 = tmp1.dot(p) # ( G.dot(p) ).dot(p)
            tmp3 = r0.dot(r0)

            # Проверка деления на ноль
            if tmp2 == 0 or tmp3 == 0:
                print(iter_count, "-я итерация, невязка:", max( abs(r0) ))
                print('Выход по защите от деления на ноль')
                return x

            # alpha = r0.dot(r0) / ( G.dot(p).dot(p) ) 
            alpha = tmp3 / tmp2 
            x = x + alpha * p

            # r1 = r0 - alpha * G.dot(p)
            r1 = r0 - alpha * tmp1

            # beta = r1.dot(r1) / r0.dot(r0)
            beta = r1.dot(r1) / tmp3

            if max( abs(r1) ) < self.eps:
                # Полученное решение удовлетворяет заданной точности
                print('Окончательная невязка:', max( abs(r1) ))
                return x
            p = r1 + beta * p
            r0 = r1
        print('Превышено максимальное число итераций:')
        print('Окончательная невязка:', max( abs(r1) ))
        return x


# Инициализиурем сетку в области Омега. 
# Можно обойтись и без использования вспомогательных
# массивов, но это усложнило бы код программы.
X_grid = [i * h for i in range(a//b * n + 1)] # список координат узлов сетки по оси x
Y_grid = [i * h for i in range(b//b * n + 1)] # список координат узлов сетки по оси y
Z_grid = [i * h for i in range(c//b * n + 1)] # список координат узлов сетки по оси z
# Для примера, пусть n = 1 (кол-во разбиений стороны c),
# a = 2, b = c = 1 =>
# X_grid = [0, 1, 2]
# Y_grid = [0, 1]
# Z_grid = [0, 1]
# => всего 2 куба в области или 2 * 6 = 12 тетраэдров

# Описание класса "Конечный элемент". Форма КЭ - тетраэдр
class FE:
    """
    Данный класс хранит следующие поля:
    * self.nodes = [n1, n2, n3, n4] - список четырех номеров узлов в глобальной нумерации.
    * self.nodes_coords = [
        [x1  y1  z1],
        [x2  y2  z2],
        [x3  y3  z3],
        [x4  y4  z4]
      ] - массив, хранящий координаты узлов, (x1,y1,z1) - координаты узла n1.
    * self.faces_dict = {
        "sigma_sigma_0": [1]
        "sigma_sigma_1": [0]
      } - словарь, используемый для хранения информации о 
      пересечении граней КЭ и границ Сигма_сигма_0 или Сигма_сигма_1.
      Элемент данного словаря - список целых чисел от 0 до 3
      для границ Сигма_сигма_0 и Сигма_сигма_1. 
      Число 0-3 - это номер узла (в локальной нумерации КЭ),
      который нужно исключить из массива self.nodes, чтобы получить нужную грань.
      Хранение граней таким образом реализовано для удобства вычисления
      L-координат на грани (т.к. важен ПОРЯДКОВЫЙ номер узла в КЭ).
      Если грани КЭ не пересегаются с Сигма_сигма - словрь пустой.
      Небольшой пример: Пусть для КЭ:
        self.nodes = [3,5,1,4] - четыре узла с глобальной нумерацией.
        Пусть узлы 3,5,1 образуют грань, которая лежит в Сигма_сигма_0
        => номер пропущенного узла - 3 (нумерация начинается с 0).

        Пусть узлы 5,1,4 образуют грань, которая так же лежит в Сигма_сигма_0
        (в нашей конфигурации Омега такого быть не может) => номер пропущенного узла - 0.

        Пусть узлы 3,5,4 образуют грань, которая лежит в Сигма_сигма_c
        => номер пропущенного узла - 2.
        Тогда словарь self.faces_dict = {
            "sigma_sigma_0": [3,0]
            "sigma_sigma_1": [2]
        }
    * self.V - объем КЭ.
    * self.L - массив, хранящий информацию о L-координатах (функциях формы)
      self.L = [
         [a_1, b_1, c_1, d_1],
         [a_2, b_2, c_2, d_2],
         [a_3, b_3, c_3, d_3],
         [a_4, b_4, c_4, d_4]
      ] где L_i(x,y,z) = a_i +  b_i*x + c_i*y + d_i*z, i = 1...4      
    * self.Hk - матрица 12х12 (4 элемента * 3 координаты) локальной СЛАУ 
    * self.Ak - вектор-столбец 12x1 локальной СЛАУ
    """

    def __init__(self, *nodes_list):
        """
        Конструкор КЭ.
        Параметры
        ---------
        nodes_list - список номеров узлов, образующих КЭ,
        в глобальной нумерации
        """
        
        assert len(nodes_list) == 4
        self.nodes = [0, 0, 0, 0]
        self.nodes_coords = np.zeros((4, 3)) # матрица нулей 4x3 
        self.faces_dict = {}

        for i in range(4):
            # заполняем узлы
            self.nodes[i] = nodes_list[i]
            # заполняем координаты узлов, 
            # координаты берутся по глобальному
            # номеру узла из словаря Nodes_id2coord 
            # (сложность обращения - O(1)):
            self.nodes_coords[i] = np.array(Nodes_id2coord[self.nodes[i]])

        if FE_INFO_PRINT:
            print("\nНовый КЭ:")
            print("узлы:", self.nodes)
            print("координаты узлов:")
            print(self.nodes_coords)

        # Инициализация L координат:
        self.init_L_coords()

        # Проверяем грани тетраэдра на 
        # пересечение с границей Сигма_сигма.
        # По очереди убираем один из узлов КЭ 
        # и проверяем полученную грань:
        for i in range(4):
            # i = 0...3
            # i - номер узла, который не входит в грань
            self.process_face(i)

        if FE_INFO_PRINT:
            print("словарь граней:")
            print(self.faces_dict)

        # Собираем локальную СЛАУ:
        self.local_SLE()
      
    def init_L_coords(self):
        """
        Функция инициализии L-координат КЭ. 
        Так же вычисляет объем КЭ (т.к используется)
        """
        # матрица вида:
        # [[1 x1 y1 z1],
        #  [1 x2 y2 z2],
        #  [1 x3 y3 z3],
        #  [1 x4 y4 4]]
        # где x_i,y_i,z_i - координаты узла i КЭ
        Vdet = np.array(
            [
                [1, *self.nodes_coords[i]]
                for i in range(4)
            ]
        )            
        # Вычисляем объем КЭ как 1/6 * |det(Vdet)|:
        self.V = 1/6 * np.abs(np.linalg.det(Vdet))

        # Обратная матрица к Vdet, 
        # нужна для опеределения L-координат:
        invVdet = np.linalg.inv(Vdet)

        # Матрица с коэф-ми функций формы (L-координаты),
        # подробное устройство см. в начале описания класса.
        self.L = np.zeros((4, 4))
        for i in range(4):
            self.L[i] = invVdet.T[i]
        
        
        if FE_INFO_PRINT:
            print("м-ца для вычисления объема:")
            print(Vdet)
            print("объём:")
            print(self.V)
            print("обратная м-ца:")
            print(invVdet)
            print("Коэф-ты L:")
            for i in range(4):
                print("L_" + str(i+1) + ":")
                print(self.L[i])

    def face_from_zero_face(self, zero_face_number):
        """ 
        Функция, которая возращает узлы грани (в глоб. нумерации)
        по номеру пропущенного узла в локальной нумерации
        Параметры
        ---------
        zero_face_number - номер пропускаемого узла
        в лок. нумер-ии (нумерация с 0)
        Например: 
            Пусть self.nodes = [1, 2, 3, 4],
            пусть zero_face_number = 2 
            => пропускаем третий элемент из массива узлов
            (нумерация с 0)
            Возращаемый результат: [1,2,4]
        """

        face = []
        for i in range(4):
            if i != zero_face_number:
                face.append(self.nodes[i])
        return face

    def process_face(self, zero_face_number):
        """ 
        Функция, которая проверяет грань на пересечение с границей Сигма_сигма
        Параметры
        ---------
        zero_face_number - номер пропускаемого узла 
        в лок. нумер-ии (нумерация с 0)
        """
        
        # face - список из трёх узлов, образующих грань
        face = self.face_from_zero_face(zero_face_number)

        if all([if_on_Sigma_sigma_0(node) for node in face]):
            # если все узлы грани на Сигма_сигма_0, 
            # заносим грань в словарь граней
            if not 'sigma_sigma_0' in self.faces_dict:
                # если в словаре граней ещё нет списка граней для
                # Сигма_сигма_0, создаем его
                self.faces_dict['sigma_sigma_0'] = []
            # заносим грань (а точнее, номер узла в локальной 
            # нумерации, который пропущен) в словарь граней:
            self.faces_dict['sigma_sigma_0'].append(zero_face_number)

        if all(if_on_Sigma_sigma_c(node) for node in face):
            # если все узлы грани на Сигма_сигма_c, 
            # заносим грань в словарь граней
            if not 'sigma_sigma_c' in self.faces_dict:
                # если в словаре граней ещё нет списка граней для
                # Сигма_сигма_c, создаем его
                self.faces_dict['sigma_sigma_c'] = []
            # заносим грань (а точнее, номер узла в локальной 
            # нумерации, который пропущен) в словарь граней:
            self.faces_dict['sigma_sigma_c'].append(zero_face_number)
        
    def S(self, face_zero_number):
        """
        Функция определения площади грани по номеру пропущенного узла
        """

        # функция вычисления длины отрезка по двух точкам:
        def lenght(p1, p2):
            # p1 = (x1,y1,z1)
            # p2 = (x2,y2,z2)
            return(math.sqrt(
                sum((p1[i]-p2[i])**2 for i in range(3))
            ))

        points = [] # список координат точек грани
        for i in range(4):
            # проходим по всем узлам
            if i != face_zero_number:
                # если локальный номер узла не равен 
                # пропускаемому, добавляем его координаты:
                points.append(self.nodes_coords[i])
        # проверка, что координат три тройки
        assert len(points) == 3

        # находим стороны грани:
        a = lenght(points[0], points[1])
        b = lenght(points[1], points[2])
        c = lenght(points[0], points[2])
        # полупеример:
        h = (a + b + c) / 2
        # формула Герона:
        if FE_INFO_PRINT:
            s = math.sqrt(h * (h - a) * (h - b) * (h - c))
            print("площадь грани", self.face_from_zero_face(face_zero_number))
            print("узел пропущен:", face_zero_number)
            print("S =", s)
        return math.sqrt(h * (h - a) * (h - b) * (h - c))

    def Phi_on_face(self, face_zero_number):
        """ 
        Возвращает матрицу (phi^T (x) E_3 ) на грани,
        где phi - функции формы, 
            E_3 - единичный тензор,
            (x) - тензорное проиизведение,
            face_zero_number - номер пропущенного узла (номер нулевой L координаты)
        """

        l = [1,1,1,1]
        l[face_zero_number] = 0
        return np.array([
            [l[0], 0, 0,    l[1], 0, 0,    l[2], 0, 0,    l[3], 0, 0],
            [0,  l[0], 0,   0, l[1], 0,    0, l[2], 0,    0, l[3], 0],
            [0,   0, l[0],  0,  0, l[1],   0, 0, l[2],    0, 0, l[3]]
        ], dtype=int)

    def local_SLE(self):
        """
        Функция для сборки локальной СЛАУ
        """
        
        # локальная матрица 12x12:
        self.Hk = np.zeros((12,12)) # инициализирована нулями
        # локальный вектор-столбец 12x1:
        self.Ak = np.zeros(12) # инициализирован нулями

        # матрица Bk из первой части ДЗ
        Bk = np.array([
            [self.L[0][1], 0, 0, self.L[1][1], 0, 0, self.L[2][1], 0, 0, self.L[3][1], 0, 0],
            [0, self.L[0][2], 0, 0, self.L[1][2], 0, 0, self.L[2][2], 0, 0, self.L[3][2], 0],
            [0, 0, self.L[0][3], 0, 0, self.L[1][3], 0, 0, self.L[2][3], 0, 0, self.L[3][3]],
            [self.L[0][2], self.L[0][1],  0,   self.L[1][2], self.L[1][1], 0,   self.L[2][2], self.L[2][1], 0,   self.L[3][2], self.L[3][1], 0],
            [self.L[0][3],  0, self.L[0][1],   self.L[1][3], 0, self.L[1][1],   self.L[2][3], 0, self.L[2][1],   self.L[3][3], 0, self.L[3][1]],
            [0, self.L[0][3],  self.L[0][2],   0, self.L[1][3], self.L[1][2],   0, self.L[2][3], self.L[2][2],   0, self.L[3][3], self.L[3][2]]
        ])
        # матрица Gk из первой части ДЗ
        # @ - произведение матриц и векторов
        Gk = Bk.T @ C @ Bk * self.V
        if FE_INFO_PRINT:
            print("Bk:")
            print(Bk)
            print("Gk:")
            print(Gk)

        # учитываем Gk в локальной матрице
        self.Hk += Gk

        
        if 'sigma_sigma_0' in self.faces_dict:
            # Если КЭ пересекает Сигма_сигма_0:
            faces = self.faces_dict['sigma_sigma_0'] # список граней, которые пересекают Сигма_сигма_0
            for f in faces:
                # проходимся по этим граням
                # f - номер узла, который пропущен, чтобы образовать грань

                # вектор Qk из первой части ДЗ
                Qk = 1/3 * self.S(f) * (self.Phi_on_face(f).T @ t_e_Sigma_sigma_0)

                # матрица Rk из первой части ДЗ
                Rk = 1/12 * mu * self.S(f) * (self.Phi_on_face(f).T @ self.Phi_on_face(f))
                for i in range(12):
                    # Нужно домножить диагональные элементы на 2, 
                    # т.к. функция self.Phi_on_face(f) возращает единичные элементы
                    Rk[i][i] *= 2
                if FE_INFO_PRINT:
                    print("Rk на Сигма_сигма_0:")
                    print(Rk)
                    print("Qk на Сигма_сигма_0:")
                    print(Qk)
                
                # учитываем результаты в локальной матрице
                self.Hk += Rk
                self.Ak += Qk
        
        if 'sigma_sigma_c' in self.faces_dict:
            # Если КЭ пересекает Сигма_сигма_c:
            faces = self.faces_dict['sigma_sigma_c']
            for f in faces:
                # проходимся по этим граням
                # f - номер узла, который пропущен, чтобы образовать грань

                # вектор Qk из первой части ДЗ
                Qk = 1/3 * self.S(f) * (self.Phi_on_face(f).T @ t_e_Sigma_sigma_c)

                # матрица Rk из первой части ДЗ
                Rk = 1/12 * mu * self.S(f) * (self.Phi_on_face(f).T @ self.Phi_on_face(f))
                for i in range(12):
                    # Нужно домножить диагональные элементы на 2, 
                    # т.к. функция self.Phi_on_face(f) возращает единичные элементы
                    Rk[i][i] *= 2

                if FE_INFO_PRINT:
                    print("Rk на Сигма_сигма_c:")
                    print(Rk)
                    print("Qk на Сигма_сигма_c:")
                    print(Qk)
                
                # учитываем результаты в локальной матрице
                self.Hk += Rk
                self.Ak += Qk
                
        if FE_INFO_PRINT:
            print('Hk:')
            print(self.Hk)
            print('Ak:')
            print(self.Ak)
                
def load_FEs_list_to_mv2(filename, Nodes_list, FEs_list, functions_list):
    """
    Функция вывода результатов в файл формата mv2
    Параметры
    ---------
    * filename - имя файла без расширения, будет .mv2
    * Nodes_list - список узлов, формат: 
        [(node_id1, (x1,y1,z1)), (node_id2, (x2,y2,z2)), ...]
    * FEs_list - список конечных элементов
    * functions_list - список функций:
        Формат:
        functions_list = [
            {
                'name': 'func1',
                'node_1': val1,
                'node_2': val2,
                ...
            },
            {
                'name': 'func2',
                'node_1': val1,
                'node_2': val2,
                ...
            }, ...
        ]
    """

    with open(filename + ".mv2", "wt") as f:
        # записываем шапку для узлов:
        f.write("{} 3 ".format(len(Nodes_list)))
        f.write("{} {}\n".format(
            len(functions_list), " ".join(
                func['name'] for func in functions_list)
        ))

        # записываем информацию об узлах:
        for node in Nodes_list:
            # Записываем id узла:
            f.write(str(node[0]) + " ")

            # Записываем кординаты узла:
            f.write(" ".join( format(coord, '8.10f')  for coord in node[1]))
            f.write(' ')
            # Записываем значение функции
            f.write(" ".join( format(func[node[0]], '8.20f')  for func in functions_list))
            f.write(" \n")

        # записываем шапку для КЭ:
        f.write("{} 12 3 BC_id mat_id mat_id_Out\n".format(len(FEs_list)))
        ind = 1 # индекс КЭ, просто записываем по порядку
        for fe in FEs_list:
            f.write(str(ind) + " ") # записываем индекс КЭ
            ind += 1
            # записываем номера узлов граней КЭ
            f.write(
                " ".join([str(i) for i in [
                    fe.nodes[0], fe.nodes[1], fe.nodes[2],
                    fe.nodes[1], fe.nodes[2], fe.nodes[3],
                    fe.nodes[0], fe.nodes[1], fe.nodes[3],
                    fe.nodes[0], fe.nodes[2], fe.nodes[3]
                ]
            ]))

            f.write(" 0 1 0\n")  # BC_id mat_id mat_id_Out

        # Записыавем рёбра границ области Омега:
        edges = set() # множество ребер, хранит уникальные элементы, операция вставки ~ O(1)
        def edge_norm(edge):
            """ 
            Функция для упорядочивания узлов в ребре по номерам,
            чтобы избежать повторов 
            """
            if edge[0] <= edge[1]:
                return edge
            else:
                return (edge[1], edge[0])
        
        # Проходим по КЭ - записываем ребра из Сигма_сигма
        for fe in FEs_list:
            for face in fe.faces_dict.values():
                for zero_face in face:
                    face_nodes = fe.face_from_zero_face(zero_face)
                    edges.add(edge_norm( (face_nodes[0], face_nodes[1]) ))
                    edges.add(edge_norm( (face_nodes[1], face_nodes[2]) ))
                    edges.add(edge_norm( (face_nodes[0], face_nodes[2]) ))
        
        # Записываем ребра на Сигма_1:
        for idx_y in range(len(Y_grid) - 1):
            y_start = Y_grid[idx_y]
            y_end = Y_grid[idx_y + 1]
            for idx_z in range(len(Z_grid) - 1):
                z_start = Z_grid[idx_z]
                z_end = Z_grid[idx_z + 1]
                # проходимся квадратиками по плоскости x = 0
                p1 = Nodes_coord2id[(0, y_start, z_start)]
                p2 = Nodes_coord2id[(0, y_end, z_start)]
                p3 = Nodes_coord2id[(0, y_end, z_end)]
                p4 = Nodes_coord2id[(0, y_start, z_end)]

                edges.add(edge_norm( (p1, p2) ))
                edges.add(edge_norm( (p1, p3) ))
                edges.add(edge_norm( (p1, p4) ))
                edges.add(edge_norm( (p2, p3) ))
                edges.add(edge_norm( (p3, p4) ))

                # проходимся квадратиками по плоскости x = a
                p1 = Nodes_coord2id[(a, y_start, z_start)]
                p2 = Nodes_coord2id[(a, y_end, z_start)]
                p3 = Nodes_coord2id[(a, y_end, z_end)]
                p4 = Nodes_coord2id[(a, y_start, z_end)]

                edges.add(edge_norm( (p1, p2) ))
                edges.add(edge_norm( (p1, p3) ))
                edges.add(edge_norm( (p1, p4) ))
                edges.add(edge_norm( (p2, p3) ))
                edges.add(edge_norm( (p3, p4) ))
        
        # Записываем ребра на Сигма_2:
        for idx_x in range(len(X_grid) - 1):
            x_start = X_grid[idx_x]
            x_end = X_grid[idx_x + 1]
            for idx_z in range(len(Z_grid) - 1):
                z_start = Z_grid[idx_z]
                z_end = Z_grid[idx_z + 1]
                # проходимся квадратиками по плоскости y = 0
                p1 = Nodes_coord2id[(x_start, 0, z_start)]
                p2 = Nodes_coord2id[(x_end, 0, z_start)]
                p3 = Nodes_coord2id[(x_end, 0, z_end)]
                p4 = Nodes_coord2id[(x_start, 0, z_end)]
                edges.add(edge_norm( (p1, p2) ))
                edges.add(edge_norm( (p2, p4) ))
                edges.add(edge_norm( (p1, p4) ))
                edges.add(edge_norm( (p2, p3) ))
                edges.add(edge_norm( (p3, p4) ))

                # проходимся квадратиками по плоскости y = b
                p1 = Nodes_coord2id[(x_start, b, z_start)]
                p2 = Nodes_coord2id[(x_end, b, z_start)]
                p3 = Nodes_coord2id[(x_end, b, z_end)]
                p4 = Nodes_coord2id[(x_start, b, z_end)]
                edges.add(edge_norm( (p1, p2) ))
                edges.add(edge_norm( (p2, p4) ))
                edges.add(edge_norm( (p1, p4) ))
                edges.add(edge_norm( (p2, p3) ))
                edges.add(edge_norm( (p3, p4) ))

        # записываем ребра в файл
        f.write(str(len(edges)) + '\n')
        for e in edges:
            f.write(str(e[0]) + ' ' + str(e[1]) + '\n')


print("Создаем сетку")
# Инициализиурем сетку в области Омега. 
# Можно обойтись и без использования вспомогательных
# массивов, но это усложнило бы код программы.
# Записываем узлы:
NodeId = 1
for x in X_grid:
    for y in Y_grid:
        for z in Z_grid:
            # Записываем в словарь элемент {номер_узла : координаты}
            Nodes_id2coord[NodeId] = (x, y, z)
            # Записываем в словарь элемент {координаты : номер_узла}
            Nodes_coord2id[(x, y, z)] = NodeId

            if x == 0 or x == a:
                # Если узел лежит в плоскостях x = 0 или x = a,
                # то добавляем его номер в множество  Sigma_u_1
                Sigma_u_1.add(NodeId)
            if y == 0 or y == b:
                # Если узел лежит в плоскостях y = 0 или y = b,
                # то добавляем его номер в множество  Sigma_u_1
                Sigma_u_2.add(NodeId)
            NodeId += 1

if FE_INFO_PRINT:
    print("Созданные узлы (id, (x,y,z)):")
    for point in Nodes_id2coord.items():
        print(point)

print("Создаем конечные элементы")
for x_ind in range(len(X_grid) - 1):
    x_start = X_grid[x_ind]
    x_end = X_grid[x_ind + 1]
    # Печать для отслеживания прогресса:
    print('слой по X,', end=' ')
    for y_ind in range(len(Y_grid) - 1):
        y_start = Y_grid[y_ind]
        y_end = Y_grid[y_ind + 1]
        for z_ind in range(len(Z_grid) - 1):
            z_start = Z_grid[z_ind]
            z_end = Z_grid[z_ind + 1]
            # Проходимся по кубам в области Омега
            # Точки куба:
            p1 = Nodes_coord2id[(x_start, y_start, z_start)]
            p2 = Nodes_coord2id[(x_end, y_start, z_start)]
            p3 = Nodes_coord2id[(x_end, y_start, z_end)]
            p4 = Nodes_coord2id[(x_start, y_start, z_end)]
            p5 = Nodes_coord2id[(x_start, y_end, z_end)]
            p6 = Nodes_coord2id[(x_end, y_end, z_end)]
            p7 = Nodes_coord2id[(x_end, y_end, z_start)]
            p8 = Nodes_coord2id[(x_start, y_end, z_start)]

            # Добавляем КЭ:
            # По цветам тетраэдров:
            # синий:
            FEs.append(FE(p4, p1, p2, p5))
            # красный
            FEs.append(FE(p4, p2, p3, p5))
            # зеленый
            FEs.append(FE(p2, p3, p6, p5))
            # желтый
            FEs.append(FE(p2, p7, p6, p5))
            # оранжевый
            FEs.append(FE(p5, p8, p2, p7))
            # Фиолетовый
            FEs.append(FE(p5, p8, p1, p2))

# Размерность глобальной СЛАУ:
dim = len(Nodes_id2coord) * 3
# Словарь для временного хранения ненулевых коэф-ов глобальной СЛАУ
G_global = {}
# Глобольный вектор, инициализирован нулями
F_global = np.zeros(dim)

# Собираем правую часть:
print('\nСборка правой части:')
start = time.time()
for fe in FEs:
    # Проходим по списку КЭ
    for i in range(12):
        # номер узла в глобальной нумерации
        global_i = (fe.nodes[i // 3] - 1) * 3 + i % 3
        F_global[global_i] += fe.Ak[i]
print("Сборка заняла", time.time() - start, "секунд")

print('\nСборка ГУ 1-рода:')
start = time.time()
for node in Sigma_u_1:
    # проходим по всем узлам Sigma_1
    for i in range(3):
        # проходим по координатам узла
        if i != 1: 
            # Пропускаем координату y для каждого узла, 
            # т.к. она не задана в условии
            global_i = (node - 1) * 3 + i % 3
            F_global[global_i] = 0
            G_global[(global_i, global_i)] = 1

for node in Sigma_u_2:
    # проходим по всем узлам Sigma_2
    for i in range(3):
        # проходим по координатам узла
        if i == 1: 
            # Пропускаем координаты x и z для каждого узла,
            # т.к. они не заданы в условии
            global_i = (node - 1) * 3 + i % 3
            F_global[global_i] = 0
            G_global[(global_i, global_i)] = 1
print("Сборка заняла", time.time() - start, "секунд")


print('\nСборка глобальной СЛАУ:')
start = time.time()
for fe in FEs:
    # Проходим по списку КЭ
    for i in range(12):
        node_id_i = fe.nodes[i // 3]
        global_i = (node_id_i - 1) * 3 + i % 3

        # Если узел в Сигма 1 и координата x или z
        if node_id_i in Sigma_u_1 and i % 3 != 1:
            # пропускаем итерацию
            continue
        # Если узел в Сигма 2 и координата y
        if node_id_i in Sigma_u_2 and i % 3 == 1:
            # пропускаем итерацию
            continue
        
        for j in range(12):
            node_id_j = fe.nodes[j // 3]
            global_j = (node_id_j - 1) * 3 + j % 3

            # Если элемент global_j, global_j уже инициализирован через ГУ,
            # т.е. если узел node_id_j в Сигма 1 и координата x или z
            # ИЛИ если узел node_id_j в Сигма 2 и координата y:
            if (node_id_j in Sigma_u_1 and j % 3 != 1) or (node_id_j in Sigma_u_2 and j % 3 == 1):
                F_global[global_i] -= fe.Hk[i][j] * F_global[global_j]           
            else:
                if not (global_i, global_j) in G_global:
                    # Если такого элемента еще не было в словаре - инициализируем нулем
                    G_global[(global_i, global_j)] = 0
                G_global[(global_i, global_j)] += fe.Hk[i][j]
print("Сборка заняла", time.time() - start, "секунд")

print("Решение методом сопряженных градиентов, размерность", dim, 'x', dim)
print('Ненулевых элементов:', len(G_global), 'из', dim*dim, '~', round(len(G_global) / dim / dim, 6), '%')

# Переносим информацию из словаря в CSR матрицу
G_global = CSR_Matrix(G_global, dim)

start = time.time()
# Создаем решатель с точностью eps и 
# максимальным кол-вом итераций max_iter:
solver = СonjugateGradientSolver(eps=0.0005, max_iter=1000)

# Решение:
X = solver(G_global, F_global)
print("Решение СЛАУ заняло", time.time() - start, "секунды")

# Создаем список функций, чтобы распределить полученное
# решение по координатам для каждого узла:
func_list = [
    {
        'name': 'u_1' # первая координата (x)
    },
    {
        'name': 'u_2' # вторая координата (y)
    },
    {
        'name': 'u_3' # третья координата (z)
    },
]

print("Создаем список функций:")
for node_id in Nodes_id2coord.keys():
    # Проходим по узлам
    func_list[0][node_id] = X[(node_id - 1) * 3]
    func_list[1][node_id] = X[(node_id - 1) * 3 + 1]
    func_list[2][node_id] = X[(node_id - 1) * 3 + 2]

filename = "urdenko"
print("Сохраняем результаты в файл " + filename + ".mv2")
load_FEs_list_to_mv2(filename, Nodes_id2coord.items(), FEs, func_list)
print("Общее время работы:", time.time() - total_start, "секунд")



